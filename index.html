<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 70%, #654321 70%, #654321 100%);
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: transparent;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #windIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
        }

        #turnIndicator {
            position: absolute;
            top: 120px;
            left: 20px;
            color: white;
            font-size: 22px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
        }

        .hp-bar {
            margin: 10px 0;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .hp-fill {
            height: 20px;
            background: #00ff00;
            border-radius: 3px;
            transition: width 0.3s;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #gameOver button {
            font-size: 24px;
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        #gameOver button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="hp-bar">
            <div>Hráč HP: <span id="playerHP">100</span></div>
            <div class="hp-fill" id="playerHPBar" style="width: 100%"></div>
        </div>
        <div class="hp-bar">
            <div>PC HP: <span id="enemyHP">100</span></div>
            <div class="hp-fill" id="enemyHPBar" style="width: 100%"></div>
        </div>
    </div>

    <div id="windIndicator">
        <div>Vietor: <span id="windValue">0</span> m/s</div>
        <div id="windArrow" style="font-size: 32px;">→</div>
    </div>

    <div id="turnIndicator">
        <span id="currentTurn">Na rade: HRÁČ</span>
    </div>

    <div id="gameOver">
        <h1 id="gameOverText"></h1>
        <button onclick="restartGame()">Hrať znova</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const GROUND_Y = canvas.height * 0.7;
        const GRAVITY = 0.3;
        const TANK_WIDTH = 60;
        const TANK_HEIGHT = 40;
        const TANK_SPEED = 2;

        let terrain = [];
        let windSpeed = 0;
        let isPlayerTurn = true;
        let canShoot = true;
        let keysPressed = {};

        function generateTerrain() {
            terrain = [];
            let y = GROUND_Y;
            for (let x = 0; x < canvas.width; x += 10) {
                y += (Math.random() - 0.5) * 15;
                y = Math.max(GROUND_Y - 100, Math.min(GROUND_Y + 50, y));
                terrain.push({x, y});
            }
        }

        function getTerrainY(x) {
            for (let i = 0; i < terrain.length - 1; i++) {
                if (x >= terrain[i].x && x < terrain[i + 1].x) {
                    const t = (x - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
                    return terrain[i].y + t * (terrain[i + 1].y - terrain[i].y);
                }
            }
            return GROUND_Y;
        }

        function generateWind() {
            windSpeed = (Math.random() - 0.5) * 0.4;
            document.getElementById('windValue').textContent = Math.abs(windSpeed * 100).toFixed(0);
            
            const arrow = document.getElementById('windArrow');
            if (windSpeed > 0) {
                arrow.textContent = '→';
                arrow.style.color = '#ff6b6b';
            } else if (windSpeed < 0) {
                arrow.textContent = '←';
                arrow.style.color = '#4ecdc4';
            } else {
                arrow.textContent = '•';
                arrow.style.color = '#95e1d3';
            }
        }

        generateTerrain();
        generateWind();

        let playerTank = {
            x: 100,
            y: getTerrainY(100) - TANK_HEIGHT,
            width: TANK_WIDTH,
            height: TANK_HEIGHT,
            hp: 100,
            color: '#2E8B57'
        };

        let enemyTank = {
            x: canvas.width - 150,
            y: getTerrainY(canvas.width - 150) - TANK_HEIGHT,
            width: TANK_WIDTH,
            height: TANK_HEIGHT,
            hp: 100,
            color: '#DC143C'
        };

        let projectiles = [];
        let dragStart = null;
        let dragCurrent = null;
        let trajectoryPoints = [];
        let gameActive = true;

        function drawTerrain() {
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#4a3319';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, terrain[0].y);
            for (let point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.stroke();
        }

        function drawTank(tank) {
            ctx.fillStyle = tank.color;
            ctx.fillRect(tank.x, tank.y, tank.width, tank.height);
            
            ctx.fillRect(tank.x + 15, tank.y - 10, 30, 15);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(tank.x + 10, tank.y + tank.height, 15, 5);
            ctx.fillRect(tank.x + 35, tank.y + tank.height, 15, 5);
        }

        function drawProjectile(proj) {
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTrajectory() {
            if (dragStart && dragCurrent) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(dragStart.x, dragStart.y);
                
                for (let point of trajectoryPoints) {
                    ctx.lineTo(point.x, point.y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(dragStart.x, dragStart.y);
                ctx.lineTo(dragCurrent.x, dragCurrent.y);
                ctx.stroke();
            }
        }

        function calculateTrajectory(startX, startY, velX, velY) {
            let points = [];
            let x = startX;
            let y = startY;
            let vx = velX;
            let vy = velY;
            
            let maxPoints = 30;
            
            for (let i = 0; i < maxPoints; i++) {
                x += vx;
                y += vy;
                vy += GRAVITY;
                
                points.push({x, y});
                
                if (y > canvas.height || x < 0 || x > canvas.width) break;
            }
            
            return points;
        }

        function shoot(tank, targetX, targetY) {
            if (!canShoot) return;
            
            const startX = tank.x + tank.width / 2;
            const startY = tank.y;
            
            const velocityX = (targetX - startX) * 0.08;
            const velocityY = (targetY - startY) * 0.08;
            
            projectiles.push({
                x: startX,
                y: startY,
                vx: velocityX,
                vy: velocityY,
                isPlayer: tank === playerTank
            });
            
            canShoot = false;
        }

        function enemyShoot() {
            if (!gameActive || !canShoot) return;
            
            setTimeout(() => {
                const startX = enemyTank.x + enemyTank.width / 2;
                const startY = enemyTank.y;
                
                const targetX = playerTank.x + playerTank.width / 2;
                const randomAngle = (Math.random() - 0.5) * 1.5;
                const randomPower = 8 + Math.random() * 4;
                
                const velocityX = -(randomPower + randomAngle);
                const velocityY = -(randomPower * 1.2) + (Math.random() - 0.5) * 2;
                
                projectiles.push({
                    x: startX,
                    y: startY,
                    vx: velocityX,
                    vy: velocityY,
                    isPlayer: false
                });
                
                canShoot = false;
            }, 1000);
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.vx += windSpeed;
                
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.vy += GRAVITY;
                
                const terrainY = getTerrainY(proj.x);
                if (proj.y > terrainY || proj.x < 0 || proj.x > canvas.width) {
                    projectiles.splice(i, 1);
                    
                    canShoot = true;
                    isPlayerTurn = !isPlayerTurn;
                    updateTurnIndicator();
                    
                    if (!isPlayerTurn && gameActive) {
                        enemyShoot();
                    }
                    continue;
                }
                
                const targetTank = proj.isPlayer ? enemyTank : playerTank;
                
                if (proj.x > targetTank.x && proj.x < targetTank.x + targetTank.width &&
                    proj.y > targetTank.y && proj.y < targetTank.y + targetTank.height) {
                    
                    targetTank.hp -= 20;
                    projectiles.splice(i, 1);
                    
                    updateHP();
                    
                    canShoot = true;
                    isPlayerTurn = !isPlayerTurn;
                    updateTurnIndicator();
                    
                    if (targetTank.hp <= 0) {
                        endGame(proj.isPlayer);
                    } else if (!isPlayerTurn && gameActive) {
                        enemyShoot();
                    }
                }
            }
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('currentTurn');
            if (isPlayerTurn) {
                indicator.textContent = 'Na rade: HRÁČ';
                indicator.style.color = '#00ff00';
            } else {
                indicator.textContent = 'Na rade: PC';
                indicator.style.color = '#ff6b6b';
            }
        }

        function updateHP() {
            document.getElementById('playerHP').textContent = Math.max(0, playerTank.hp);
            document.getElementById('enemyHP').textContent = Math.max(0, enemyTank.hp);
            document.getElementById('playerHPBar').style.width = Math.max(0, playerTank.hp) + '%';
            document.getElementById('enemyHPBar').style.width = Math.max(0, enemyTank.hp) + '%';
            
            if (playerTank.hp < 50) {
                document.getElementById('playerHPBar').style.background = '#ffaa00';
            }
            if (playerTank.hp < 25) {
                document.getElementById('playerHPBar').style.background = '#ff0000';
            }
            
            if (enemyTank.hp < 50) {
                document.getElementById('enemyHPBar').style.background = '#ffaa00';
            }
            if (enemyTank.hp < 25) {
                document.getElementById('enemyHPBar').style.background = '#ff0000';
            }
        }

        function endGame(playerWon) {
            gameActive = false;
            document.getElementById('gameOverText').textContent = playerWon ? 'VÍŤAZSTVO!' : 'PREHRA!';
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            playerTank.hp = 100;
            enemyTank.hp = 100;
            playerTank.x = 100;
            playerTank.y = getTerrainY(100) - TANK_HEIGHT;
            enemyTank.x = canvas.width - 150;
            enemyTank.y = getTerrainY(canvas.width - 150) - TANK_HEIGHT;
            projectiles = [];
            gameActive = true;
            isPlayerTurn = true;
            canShoot = true;
            
            generateTerrain();
            generateWind();
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('playerHPBar').style.background = '#00ff00';
            document.getElementById('enemyHPBar').style.background = '#00ff00';
            updateHP();
            updateTurnIndicator();
        }

        function updateTankPosition() {
            if (keysPressed['ArrowLeft'] && isPlayerTurn && canShoot) {
                playerTank.x = Math.max(0, playerTank.x - TANK_SPEED);
                playerTank.y = getTerrainY(playerTank.x + playerTank.width / 2) - TANK_HEIGHT;
            }
            if (keysPressed['ArrowRight'] && isPlayerTurn && canShoot) {
                playerTank.x = Math.min(canvas.width - playerTank.width, playerTank.x + TANK_SPEED);
                playerTank.y = getTerrainY(playerTank.x + playerTank.width / 2) - TANK_HEIGHT;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawTerrain();
            drawTank(playerTank);
            drawTank(enemyTank);
            
            for (let proj of projectiles) {
                drawProjectile(proj);
            }
            
            drawTrajectory();
        }

        function gameLoop() {
            if (gameActive) {
                updateProjectiles();
                updateTankPosition();
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (!gameActive || !isPlayerTurn || !canShoot) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            dragStart = {
                x: playerTank.x + playerTank.width / 2,
                y: playerTank.y
            };
            dragCurrent = {x, y};
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameActive || !isPlayerTurn || !canShoot) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (dragStart) {
                dragCurrent = {x, y};
                
                const velX = (x - dragStart.x) * 0.08;
                const velY = (y - dragStart.y) * 0.08;
                trajectoryPoints = calculateTrajectory(dragStart.x, dragStart.y, velX, velY);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!gameActive || !isPlayerTurn || !canShoot) return;
            
            if (dragStart && dragCurrent) {
                shoot(playerTank, dragCurrent.x, dragCurrent.y);
                dragStart = null;
                dragCurrent = null;
                trajectoryPoints = [];
            }
        });

        window.addEventListener('resize', () => {
            const oldWidth = canvas.width;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const scale = canvas.width / oldWidth;
            enemyTank.x = canvas.width - 150;
            enemyTank.y = getTerrainY(enemyTank.x) - TANK_HEIGHT;
            playerTank.y = getTerrainY(playerTank.x) - TANK_HEIGHT;
            
            generateTerrain();
        });

        gameLoop();
    </script>
</body>
</html>
<!-- koment -->
<!-- KOKOT -->
