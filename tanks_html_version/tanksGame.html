<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TanksGame</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #87CEEB;
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: transparent;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #windIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
        }

        #turnIndicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 22px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
        }

        .hp-bar {
            margin: 10px 0;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .hp-fill {
            height: 20px;
            background: #00ff00;
            border-radius: 3px;
            transition: width 0.3s;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #gameOver button {
            font-size: 24px;
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        #gameOver button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div class="hp-bar">
                <div>Hráč HP: <span id="playerHP">100</span></div>
                <div class="hp-fill" id="playerHPBar" style="width: 100%"></div>
            </div>
            <div class="hp-bar">
                <div>PC HP: <span id="enemyHP">100</span></div>
                <div class="hp-fill" id="enemyHPBar" style="width: 100%"></div>
            </div>
        </div>

        <div id="windIndicator">
            <div>Vietor: <span id="windValue">0</span> m/s</div>
            <div id="windArrow" style="font-size: 32px;">→</div>
        </div>

        <div id="turnIndicator">
            <span id="currentTurn">Na rade: HRÁČ</span>
        </div>

        <div id="gameOver">
            <h1 id="gameOverText"></h1>
            <button onclick="restartGame()">Hrať znova</button>
        </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const GROUND_Y = canvas.height * 0.7;
        const GRAVITY = 0.5;
        const TANK_WIDTH = 60;
        const TANK_HEIGHT = 30;
        const TANK_SPEED = 2;
        const TERRAIN_COLOR = '#654321'; // Dark Brown

        let terrain = [];
        let windSpeed = 0;
        let isPlayerTurn = true;
        let canShoot = true;
        let keysPressed = {};

        function generateTerrain() {
            /*kreslime dve sinusoidy. Jednu vo velkej skale a druhu v malej 
            pre male nerovnosti. V buducnosti mozme menenim konstant zvysovat 
            uroven levelov (rovna mapa->oble kopce->strme caste svahy (? napad)*/
            terrain = [];
            const phase1 = Math.random() * 100;
            const phase2 = Math.random() * 100;

            for (let x = 0; x <= canvas.width; x += 5) {
                let y = GROUND_Y;
                y += Math.sin(x * 0.006 + phase1) * 90; // Large hills
                y += Math.sin(x * 0.02 + phase2) * 30;  // Small bumps
                
                y = Math.max(100, Math.min(canvas.height - 50, y));
                terrain.push({x, y});
            }
        }

        function getTerrainY(x) {
            const step = 5;
            const index = Math.floor(x / step);

            if (index < 0 || index >= terrain.length - 1) return GROUND_Y;

            const t = (x - terrain[index].x) / step;
            return terrain[index].y + t * (terrain[index + 1].y - terrain[index].y);
        }

        function generateWind() {
            windSpeed = (Math.random() - 0.5) * 0.4;
            document.getElementById('windValue').textContent = Math.abs(windSpeed * 100).toFixed(0);
            
            const arrow = document.getElementById('windArrow');
            if (windSpeed > 0) {
                arrow.textContent = '→';
                arrow.style.color = '#ff6b6b';
            } else if (windSpeed < 0) {
                arrow.textContent = '←';
                arrow.style.color = '#4ecdc4';
            } else {
                arrow.textContent = '•';
                arrow.style.color = '#95e1d3';
            }
        }

        generateTerrain();
        generateWind();

        let playerTank = {
            x: 100,
            y: getTerrainY(100 + TANK_WIDTH / 2) - TANK_HEIGHT,
            width: TANK_WIDTH,
            height: TANK_HEIGHT,
            hp: 100,
            color: '#2E8B57',
            texture: null // Ready for upgrade: new Image()
        };

        let enemyTank = {
            x: canvas.width - 150,
            y: getTerrainY(canvas.width - 150 + TANK_WIDTH / 2) - TANK_HEIGHT,
            width: TANK_WIDTH,
            height: TANK_HEIGHT,
            hp: 100,
            color: '#DC143C',
            texture: null // Ready for upgrade: new Image()
        };

        let projectiles = [];
        let dragStart = null;
        let dragCurrent = null;
        let trajectoryPoints = [];
        let gameActive = true;

        function drawTerrain() {

            const surfacePath = new Path2D();
            surfacePath.moveTo(0, terrain[0].y);
            for (let point of terrain) {
                surfacePath.lineTo(point.x, point.y);
            }
            
            const fillPath = new Path2D(surfacePath);
            fillPath.lineTo(canvas.width, canvas.height);
            fillPath.lineTo(0, canvas.height);
            fillPath.closePath();
            

            ctx.fillStyle = TERRAIN_COLOR;
            ctx.fill(fillPath);
            
            ctx.strokeStyle = '#4a3319';
            ctx.lineWidth = 3;
            ctx.stroke(surfacePath);
        }

        function drawTank(tank) {
            // vypocet uhla podla terenu
            const groundLeft = getTerrainY(tank.x);
            const groundRight = getTerrainY(tank.x + tank.width);
            const angle = Math.atan2(groundRight - groundLeft, tank.width);

            ctx.save();
            
            // rotovat tank okolo stredu podla terenu
            ctx.translate(tank.x + tank.width / 2, tank.y + tank.height / 2);
            ctx.rotate(angle);
            ctx.translate(-tank.width / 2, -tank.height / 2);

            if (tank.texture) {
                ctx.drawImage(tank.texture, 0, 0, tank.width, tank.height);
                ctx.restore();
                return;
            }

            const isEnemy = tank.color === '#DC143C';

            // pasy
            ctx.fillStyle = '#2c2c2c';
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(0, tank.height - 10, tank.width, 10, 5);
            } else {
                ctx.fillRect(0, tank.height - 10, tank.width, 10);
            }
            ctx.fill();
            
            // kolesa na pasoch
            ctx.fillStyle = '#555';
            ctx.beginPath();
            for(let i = 6; i < tank.width; i += 12) {
                ctx.moveTo(i + 3, tank.height - 5);
                ctx.arc(i, tank.height - 5, 3, 0, Math.PI * 2);
            }
            ctx.fill();

            // telo tanku
            ctx.fillStyle = tank.color;
            ctx.beginPath();
            ctx.moveTo(5, tank.height - 10);
            ctx.lineTo(tank.width - 5, tank.height - 10);
            ctx.lineTo(tank.width - 10, tank.height - 22);
            ctx.lineTo(10, tank.height - 22);
            ctx.closePath();
            ctx.fill();

            // vezicka tanku
            ctx.beginPath();
            ctx.arc(tank.width / 2, tank.height - 22, 9, Math.PI, 0);
            ctx.fill();
            
            // hlaven - delo
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';            
            ctx.beginPath();
            ctx.moveTo(tank.width / 2, tank.height - 25);            
            const barrelAngle = isEnemy ? -Math.PI * 0.8 : -Math.PI * 0.2;
            ctx.lineTo(tank.width / 2 + Math.cos(barrelAngle) * 22, tank.height - 25 + Math.sin(barrelAngle) * 22);
            ctx.stroke();

            ctx.restore();
        }

        function drawProjectile(proj) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTrajectory() {
            if (dragStart && dragCurrent) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(dragStart.x, dragStart.y);
                
                for (let point of trajectoryPoints) {
                    ctx.lineTo(point.x, point.y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                
            }
        }

        function calculateTrajectory(startX, startY, velX, velY) {
            let points = [];
            let x = startX;
            let y = startY;
            let vx = velX;
            let vy = velY;
            
            let maxPoints = 30;
            
            for (let i = 0; i < maxPoints; i++) {
                x += vx;
                y += vy;
                vy += GRAVITY;
                
                points.push({x, y});
                
                if (y > canvas.height || x < 0 || x > canvas.width) break;
            }
            
            return points;
        }

        function shoot(tank, targetX, targetY) {
            if (!canShoot) return;
            
            const startX = tank.x + tank.width / 2;
            const startY = tank.y;
            
            const velocityX = (targetX - startX) * 0.08;
            const velocityY = (targetY - startY) * 0.08;
            
            projectiles.push({
                x: startX,
                y: startY,
                vx: velocityX,
                vy: velocityY,
                isPlayer: tank === playerTank
            });
            
            canShoot = false;
        }

        function enemyShoot() {
            if (!gameActive || !canShoot) return;
            
            setTimeout(() => {
                const startX = enemyTank.x + enemyTank.width / 2;
                const startY = enemyTank.y;
                
                const targetX = playerTank.x + playerTank.width / 2;
                const randomAngle = (Math.random() - 0.5) * 1.5;
                const randomPower = 8 + Math.random() * 4;
                
                const velocityX = -(randomPower + randomAngle);
                const velocityY = -(randomPower * 1.2) + (Math.random() - 0.5) * 2;
                
                projectiles.push({
                    x: startX,
                    y: startY,
                    vx: velocityX,
                    vy: velocityY,
                    isPlayer: false
                });
                
                canShoot = false;
            }, 1000);
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.vx += windSpeed;
                
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.vy += GRAVITY;
                
                const terrainY = getTerrainY(proj.x);
                if (proj.y > terrainY || proj.x < 0 || proj.x > canvas.width) {
                    projectiles.splice(i, 1);
                    
                    canShoot = true;
                    isPlayerTurn = !isPlayerTurn;
                    updateTurnIndicator();
                    
                    if (!isPlayerTurn && gameActive) {
                        enemyShoot();
                    }
                    continue;
                }
                
                const targetTank = proj.isPlayer ? enemyTank : playerTank;
                
                if (proj.x > targetTank.x && proj.x < targetTank.x + targetTank.width &&
                    proj.y > targetTank.y && proj.y < targetTank.y + targetTank.height) {
                    
                    targetTank.hp -= 20;
                    projectiles.splice(i, 1);
                    
                    updateHP();
                    
                    canShoot = true;
                    isPlayerTurn = !isPlayerTurn;
                    updateTurnIndicator();
                    
                    if (targetTank.hp <= 0) {
                        endGame(proj.isPlayer);
                    } else if (!isPlayerTurn && gameActive) {
                        enemyShoot();
                    }
                }
            }
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('currentTurn');
            if (isPlayerTurn) {
                indicator.textContent = 'Na rade: HRÁČ';
                indicator.style.color = '#00ff00';
            } else {
                indicator.textContent = 'Na rade: PC';
                indicator.style.color = '#ff6b6b';
            }
        }

        function updateHP() {
            document.getElementById('playerHP').textContent = Math.max(0, playerTank.hp);
            document.getElementById('enemyHP').textContent = Math.max(0, enemyTank.hp);
            document.getElementById('playerHPBar').style.width = Math.max(0, playerTank.hp) + '%';
            document.getElementById('enemyHPBar').style.width = Math.max(0, enemyTank.hp) + '%';
            
            if (playerTank.hp < 50) {
                document.getElementById('playerHPBar').style.background = '#ffaa00';
            }
            if (playerTank.hp < 25) {
                document.getElementById('playerHPBar').style.background = '#ff0000';
            }
            
            if (enemyTank.hp < 50) {
                document.getElementById('enemyHPBar').style.background = '#ffaa00';
            }
            if (enemyTank.hp < 25) {
                document.getElementById('enemyHPBar').style.background = '#ff0000';
            }
        }

        function endGame(playerWon) {
            gameActive = false;
            document.getElementById('gameOverText').textContent = playerWon ? 'VÍŤAZSTVO!' : 'PREHRA!';
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            generateTerrain();
            generateWind();
            
            playerTank.hp = 100;
            enemyTank.hp = 100;
            playerTank.x = 100;
            playerTank.y = getTerrainY(100 + TANK_WIDTH / 2) - TANK_HEIGHT;
            enemyTank.x = canvas.width - 150;
            enemyTank.y = getTerrainY(canvas.width - 150 + TANK_WIDTH / 2) - TANK_HEIGHT;
            projectiles = [];
            gameActive = true;
            isPlayerTurn = true;
            canShoot = true;
            
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('playerHPBar').style.background = '#00ff00';
            document.getElementById('enemyHPBar').style.background = '#00ff00';
            updateHP();
            updateTurnIndicator();
        }

        function updateTankPosition() {
            if (keysPressed['ArrowLeft'] && isPlayerTurn && canShoot) {
                playerTank.x = Math.max(0, playerTank.x - TANK_SPEED);
                playerTank.y = getTerrainY(playerTank.x + playerTank.width / 2) - TANK_HEIGHT;
            }
            if (keysPressed['ArrowRight'] && isPlayerTurn && canShoot) {
                playerTank.x = Math.min(canvas.width - playerTank.width, playerTank.x + TANK_SPEED);
                playerTank.y = getTerrainY(playerTank.x + playerTank.width / 2) - TANK_HEIGHT;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawTerrain();
            drawTank(playerTank);
            drawTank(enemyTank);
            
            for (let proj of projectiles) {
                drawProjectile(proj);
            }
            
            drawTrajectory();
        }

        function gameLoop() {
            if (gameActive) {
                updateProjectiles();
                updateTankPosition();
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (!gameActive || !isPlayerTurn || !canShoot) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            dragStart = {
                x: playerTank.x + playerTank.width / 2,
                y: playerTank.y
            };
            dragCurrent = {x, y};
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameActive || !isPlayerTurn || !canShoot) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (dragStart) {
                dragCurrent = {x, y};
                
                const velX = (x - dragStart.x) * 0.08;
                const velY = (y - dragStart.y) * 0.08;
                trajectoryPoints = calculateTrajectory(dragStart.x, dragStart.y, velX, velY);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!gameActive || !isPlayerTurn || !canShoot) return;
            
            if (dragStart && dragCurrent) {
                shoot(playerTank, dragCurrent.x, dragCurrent.y);
                dragStart = null;
                dragCurrent = null;
                trajectoryPoints = [];
            }
        });

        window.addEventListener('resize', () => {
            const oldWidth = canvas.width;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const scale = canvas.width / oldWidth;
            enemyTank.x = canvas.width - 150;
            
            generateTerrain();
            enemyTank.y = getTerrainY(enemyTank.x + TANK_WIDTH / 2) - TANK_HEIGHT;
            playerTank.y = getTerrainY(playerTank.x + TANK_WIDTH / 2) - TANK_HEIGHT;
        });

        gameLoop();
    </script>
</body>
</html>